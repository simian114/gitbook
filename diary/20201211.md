---
description: 흠.. 루비는 뭔가 이상하다
---

# 20201211\(금\)

## 2020-12-11

### 1. 학습 날짜

* 2020-12-11

### 2. 학습 시간

* 09:00 ~ 22:00

### 3. 학습 범위 및 주제

* 루비

### 4. 학습 목표

* 루비 학습

### 5. 과제 제출

* 
### 6. 상세 학습 내용

* 루비
  * 루비는 완전 객체 지향 언어다.
    * 심지어 `nil` 도 아무것도 없음을 가리키는 객체다
  * 루비는 관습이 정말 중요하다. 심지어 스크립트 실행에도 영향을 미친다.
  * 루비는 다중 상속이 되지 않는다. 그 대신 `mix` 라는 개념이 있다.
    * 이 `mix`를 이용하기 위해서는 `모듈`을 사용해야한다. 모듈 또한 루비의 개념이다. 함수와 상수를 모아놓은 네임스페이스와 같은 개념이지만, 클래스에서 이 모듈을 하나 이상 `include` 할 수 있다. include 하게 되면 모듈에 존재하는 모든 메써드와 상수들을 `include` 한 클래스에서 자신의 것인거 마냥 사용할 수 있다.
  * 배열과 해시가 있다.
    * 배열은 인덱스가 정수고 해시는 인덱스에 무엇이든 올 수 있다.
    * 존재하지 않는 인덱스에 접근하면 `nil`을 리턴한다.
  * 심볼이라는 또다른 개념의 상수가 있다.
    * 다른 언어에서 상수를 사용하기 위해서는 특정한 값으로 선언 및 초기화를 해줬어야 한다.
    * 루비에서 심볼이란 사용자는 그냥 사용하기만 하면 루비인터프리터가 알아서 상수화를 해주는 상수다.
    * 즉 사용자는 초기화를 할 필요 없이 그냥 사용하면 된다.
    * 프로그램 내에서 하나의 심볼은 모두 같은 값을 유지한다.
    * 주로 해시의 인덱스로 사용된다.
      * 해시의 인덱스로 사용하면 해시를 선언하는데도 코딩에 이점이 있다.
  * 코드 블록
    * 코드 블록은 반드시 메써드 뒤에 위치한다.
    * 코드 블록을 정확히 정의하기에는 아직 공부가 부족한 것 같다.
    * 메써드 내에서 `yield`를 호출하면 코드 블록이 실행된다.
    * 메써드에서 코드 블록으로 인자를 건네줄 수 있다.
    * 반대로 코드블록에서도 메써드로 인자를 줄 수 있다.
    * 이 둘은 con-current 하게 동작한다고 보면 된다.
  * 반복자
    * 반복자의 정의는 코드 블록을 호출할 수 있는 메써드를 이야기 한다.
    * 배열을 생각해보면 배열의 each 메써느는 코드 블록을 호출할 수 있다.
    * 즉 메써드 내부에 yield가 있는것으로 보인다.
    * 보통의 반복자는 메써드를 호출한 객체 집합의 모든 원소를 하나하나 yield을 이용해 코드블록으로 내보낸다.
  * 열거자
    * 배열이나 해시에 대해 `to_enum`을 호출하면 `enumerator` 객체를 얻을 수 있다.
    * 열거자 또한 반복자다.
    * 열거자는 `enum_test.next`와 같이 next를 실행하면 반복을 하나 진행한다.
  * `loop`
    * 블록을 그저 반복적으로 실행하기만 하는 메써드다.
    * `loop`을 사용할 때는 특정한 조건에 의해 반복이 정지되도록 하는게 중요하다.

### 7. 오늘 학습 내용에 대한 개인적인 총평

* 솔직히 아직은 잘 모르겠다. 지금 공부하는 방법이 조금은 나사가 빠진 방법인 것 같다. 정말 쓸모없는 강의에 너무 시간을 쏟았고, 또한 지금 보는 책이 프로그래밍 루비 라는 아주 유명한 책인데 이 책도 루비를 처음 보는 사람한테는 조금 무리가 있는 것 같다. 예제 실행하는 것도 참 힘들다;;

### 8. 다음 학습 계획

* 루비 공부

