---
description: 간단히 루비 맛을 본다.
---

# Chapter2 Ruby.new

## 2.1 객체지향 언어 루비

* 루비는 진정한 객체 지향 언어다.
* 모든 객체는 고유한 객체 아이디를 가진다.
  * 각 객체에는 객체별로 고유한 값을 가질 수 있는 인스턴스 변수를 정의할 수 있다.
  * 인스턴스 변수에는 객체의 상태가 저장된다.
* 클래스 정의 안에서 인스턴스 메서드를 정의할 수도 있다.
  * 이 메서드는 클래스 내부적으로 호출하거나 외부에서 사용할 수 있는 코드의 묶음이다.
  * 인스턴스 메서드들은 객체의 인스턴스 변수, 즉 객체의 상태에 접근할 수 있다.
  * 메서드는 객체에 메시지를 보내 호출할 수 있다. 메시지에는 메서드 이름과 메서드에 필요한 매개 변수들이 포함된다.
  * 객체가 메시지를 받으면 자신의 클래스에서 해당 메서드를 찾는다. 찾으면 실행하고 못찾으면...
* `puts`
  * 루비 표준 메서드다. 인자들을 콘솔에 출력하고 마지막에 줄바꿈을 추가한다.
  * `puts` 두 가지 역할을 한다. 첫 째는 인자를 출력하는 것이고 둘 째는 줄바꿈을 하는 것. 두 가지 일을 하기 때문에 `thread`나 `process`를 다룰때는 사용하지 않는 것이 좋다. 이 때는 `print` 를 사용하자.\(왜냐면 puts로 인자르 출력하고 줄바꿈을 하려고 할 때 컨텍스트 스위칭이 될 수도 있기 때문\)

## 2.2 루비의 기초

* 주석은 \# 로 시작한다.
* 메써드의 정의는 `def` 로 시작하고 `end`로 끝난다.
  * 인자를 넣어주는 괄호는 없어도 된다.
    * 우선순위에 영향을 줄 수 있다.
    * 그래도 왠만하면 넣는게 좋다.
  * 메써드의 끝은 `end`다.
* `Double quote`와 `Single quote`는 다르다.
  * `Double`는 내부적으로 처리하는게 더 많다. 따라서 `Single` 보다 `Double`의 속도가 느리다.
  * `Double`를 사용하면 아래 처럼 변수를 넣을 수 있다.

    ```ruby
    puts "This is Double quote! #{var}"
    ```
* 루비에서는 이름으로 용도를 구분한다.
  * 식별자는 영어로 쓴다.
  * 심볼, 메써드, 변수: `snake_case`
    * `snake_case`
    * 숫자를 쓰지 않는다.
  * 클래스, 모듈
    * `CamelCase`
    * `HTTP`와 같은 약어는 대문자로 유지한다.
  * 파일, 디렉토리 이름
    * `snake_case`
  * 상수
    * `SCREAMING_SNAKE_CASE`
  * 서술형 메써드\(`boolean`을 리턴하는 메써드\)
    * 반드시 이름이 `?`로 끝나야 한다.
    * 서술형 메써드가 아니면 `?`로 끝나면 절대 안된다.
  * 단정 메써드\(`is`, `does`, `can`\) 같은 보조 전치사를 붙이지 마라
  * 이항 연산자를 정의할 때에는 매개변수 이름을 `other`로 해라
  * 인수턴수 변수는 `@`로 시작한다.
  * 클래스 변수는 `@@`로 시작한다.
* 전역 변수는 `$`로 시작한다.
* 배열과 해시는 색인된 컬렉션이다.
  * 문자열 배열을 만들 때 `%w` 를 사용하면 간단히 만들 수 있다. 아래의 두 경우는 같은 결과를 나타낸다.

    ```ruby
    arr1 = ["1", "2", "3"]
    arr2 = %w {1, 2, 3}
    ```

  * 해시를 사용할 때 심볼을 사용하면 조금더 쉽게 초기화를 할 수 있다.
  * 심볼은 C언어로 생각하면 define 으로 선언된 값이지만, 따로 초기화 해줄 필요는 없다. 루비에서 알아처 처리해준다. 프로그램 전체에서 공유가 된다.
  * 배열과 해시에 키, 인덱스로 접근할 때 없는 요소라면 `nil`을 반환한다.
* `nil` 또한 객체다.
  * 아무것도 없음을 뜻한다.
* 문자열 길이 0 은 `false` 가 아니다

## 2.7 블록과 반복자

* 코드 블록은 매채 변수처럼 메서드 호출과 결합할 수 있는 코드다.

  코드 블록은 `{}` 나 `do end` 로 묶인다.

* 메서드는 `yield`를 통해서 블록을 호출할 수 있다.

  ```ruby
  block_test.test do |var|
    puts "variable from method #{var}"
  end
  ```

* 메서드에서 `yield` 에 인자를 넣으면 코드 블록에 전송된다.
* 코드블록을 반복자 구현에 사용한다.

