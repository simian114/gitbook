# 이벤트 위임

이벤트 위임?

* 로그인 창을 모달로 띄우는 경우를 생각해보자.
* 이 모달창은 로그인 버튼을 누르면 동적으로 생기고 끝나면 동적으로 사라진다.
* 그런데 무식하게? 코드를 작성하고 실행을 해보자.
* 처음에는 분명 로그인이 잘된다. 하지만 로그아웃을하고 다시 로그인을 하게 되면 이때부터 무언가가 꼬이게 된다.
* 도대체 왜 그럴까? 아무리 무식하게 코딩을 했다고해도 분명 DOM 요소 자체는 생성되고 사라지는게 눈에보이는데...?
  * 정답은 **이벤트를 삭제해주지 않아서 그렇다**
* 이벤트를 삭제해주지 않았다고?
  * 로그인창 모달을 띄우면 그 모달창 하나에도 정말 수많은 이벤트가 걸리게 된다.
  * 이때 모달창이 사라질 때 이벤트에 대한 처리를 해주지 않는다면, 이 이벤트는 계속 남아 있게 된다. 그리고 메모리 leak의 범인이 되어서 웹이 동작하지 않게 만드는 원인이 된다.
* 자 그러면 해결법은 간단하다. 모달창이 사라질 때 마다 이 이벤트를 없애면 된다.
* 이렇게 하면 문제는 해결되지만, 모달창의 생성과 소멸에 너무 많은 작업이 할당되어 버린다.\(모달창 하나에는 이벤트가 여러개가 걸리기 때문\) 따라서 개발자라면 당연히 더 좋은 방법을 찾아야한다. 그렇다면 더 좋은 방법은 대체 뭐가 있을까?
* 여기서 나오는 해답 중 하나가 바로 **이벤트 위임**이다.
* 이벤트 위임. 말 그대로 이벤트를 무언가에게 넘기는? 기능이다. 그렇다면 이 이벤트를 어디로 옮길것인가? 간단하다. 상위 객체로 옮기는 것이다!
  * 그렇다면 의문이 하나 생긴다. 이벤트를 모달창이 아닌 모달창의 상위 객체에 정의했는데 어떻게 해당 모달창에서 이벤트를 사용할 수 있다는 것인가?
  * 이건 JS의 특징이기 때문에 가능한것이다. **JS에서 사용자의 액션에 의해 이벤트 발생 시 이벤트는 document 레벨까지 버블링되어 올라간다.** 쉽게 말해서 자식 클래스에 메서드가 선언되어 있지 않으면 부모 클래스의 메서드까지 찾아가는 것처럼, 이벤트도 해당 객체에 선언되어 있지 않다면 해당 객체의 상위로 올라가서 이벤트를 찾게 되는것이다.
* 이러한 원리를 사용하는게 바로 **이벤트 위임**이다. 특정 엘리먼트에 하나하나 이벤트를 등록하지 않고 하나의 부모에 이벤트를 등록하여 부모에게 이벤트를 위임하는 것.

